# Distribui√ß√£o Beta

> **Tipo:** Distribui√ß√£o de Probabilidade Cont√≠nua  
> **Complexidade:** ‚≠ê‚≠ê‚≠ê‚≠ê‚òÜ (Avan√ßado)  
> **Aplica√ß√£o:** Modelagem de Propor√ß√µes, Probabilidades, [[Acur√°cia]]

---

## üéØ O que √© a Distribui√ß√£o Beta?

A **distribui√ß√£o Beta** √© uma fam√≠lia de [[Distribui√ß√µes_de_Probabilidade|distribui√ß√µes cont√≠nuas]] definidas no intervalo **[0, 1]**, tornando-a **perfeita** para modelar:
- Propor√ß√µes
- Probabilidades
- Taxas
- **[[Acur√°cia|Acur√°cias]] de modelos** ‚≠ê

**Por que √© central no [[The_Balanced_Accuracy_and_Its_Posterior_Distribution|artigo]]?**
Resolve o problema de [[Intervalos_de_Confian√ßa|intervalos de confian√ßa]] que violam [0,1]!

---

## üìê Defini√ß√£o Matem√°tica

### Fun√ß√£o Densidade de Probabilidade (PDF)

```
Beta(x; Œ±, Œ≤) = [x^(Œ±-1) √ó (1-x)^(Œ≤-1)] / B(Œ±, Œ≤)
```

Onde:
- **x ‚àà [0, 1]:** Valor da vari√°vel (ex: acur√°cia)
- **Œ± > 0:** Par√¢metro de forma ("sucessos" + 1)
- **Œ≤ > 0:** Par√¢metro de forma ("falhas" + 1)
- **B(Œ±, Œ≤):** Fun√ß√£o Beta (constante normalizadora)

### Fun√ß√£o Beta

```
B(Œ±, Œ≤) = ‚à´‚ÇÄ¬π t^(Œ±-1) √ó (1-t)^(Œ≤-1) dt

        = Œì(Œ±) √ó Œì(Œ≤) / Œì(Œ± + Œ≤)
```

Onde **Œì** √© a fun√ß√£o Gamma (generaliza√ß√£o do fatorial).

**Para inteiros:**
```
B(Œ±, Œ≤) = (Œ±-1)! √ó (Œ≤-1)! / (Œ±+Œ≤-1)!
```

---

## üé® Interpreta√ß√£o dos Par√¢metros

### Forma Intuitiva

**Contexto [[Infer√™ncia_Bayesiana|Bayesiano]]:**
```
Œ± = n√∫mero de "sucessos" + 1
Œ≤ = n√∫mero de "falhas" + 1
```

**Exemplo [[Aplica√ß√£o_ao_IoT_IDS|IDS]]:**
```
95 classifica√ß√µes corretas
5 classifica√ß√µes incorretas

‚Üí Beta(96, 6)

Œ± = 95 + 1 = 96
Œ≤ = 5 + 1 = 6
```

### Efeito dos Par√¢metros

#### Œ±: "For√ßa dos Sucessos"
- ‚Üë Œ±: distribui massa para **direita** (valores altos)
- ‚Üì Œ±: distribui massa para **esquerda** (valores baixos)

#### Œ≤: "For√ßa das Falhas"  
- ‚Üë Œ≤: distribui massa para **esquerda** (valores baixos)
- ‚Üì Œ≤: distribui massa para **direita** (valores altos)

#### Œ± + Œ≤: "For√ßa das Evid√™ncias"
- ‚Üë (Œ±+Œ≤): distribui√ß√£o mais **concentrada** (menos incerteza)
- ‚Üì (Œ±+Œ≤): distribui√ß√£o mais **espalhada** (mais incerteza)

---

## üìä Formas da Beta

### Visualiza√ß√£o de Formas Cl√°ssicas

```
Beta(1, 1): ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ  Uniforme (total ignor√¢ncia)

Beta(2, 2):    ‚ï±‚ï≤       Sim√©trica suave
              ‚ï±  ‚ï≤

Beta(5, 2):      ‚ï±‚ï≤     Pico √† direita (alta acur√°cia)
                ‚ï±  ‚ï≤___

Beta(2, 5): ___‚ï±  ‚ï≤     Pico √† esquerda (baixa acur√°cia)
               ‚ï≤  ‚ï±

Beta(0.5, 0.5): U       Forma de U (valores extremos)

Beta(20, 20):   ‚ñ≤       Muito concentrada (muita evid√™ncia)
```

### Casos Especiais

**Beta(1, 1):**
```
Uniforme em [0,1]
f(x) = 1
```
Prior n√£o-informativo - total ignor√¢ncia.

**Beta(Œ±, Œ±) com Œ± grande:**
```
Aproxima Normal
Sim√©trica, concentrada em 0.5
```

**Beta(Œ±, 1) ou Beta(1, Œ≤):**
```
Distribui√ß√µes crescentes/decrescentes
```

---

## üìà Momentos e Estat√≠sticas

### M√©dia (Esperan√ßa)

```
E[X] = Œº = Œ± / (Œ± + Œ≤)
```

**Exemplo:**
```
Beta(91, 11):
Œº = 91 / (91 + 11) = 91/102 ‚âà 0.892 = 89.2%
```

### Moda

```
Moda = (Œ± - 1) / (Œ± + Œ≤ - 2)   se Œ±, Œ≤ > 1
```

**Exemplo:**
```
Beta(91, 11):
Moda = (91-1) / (91+11-2) = 90/100 = 0.90 = 90%
```

**Interessante:** A moda ‚âà acur√°cia observada (90/100)!

### Mediana

N√£o tem forma fechada, mas para sim√©trica (Œ±=Œ≤):
```
Mediana = 0.5
```

### Vari√¢ncia

```
Var(X) = œÉ¬≤ = Œ±Œ≤ / [(Œ±+Œ≤)¬≤(Œ±+Œ≤+1)]
```

**Exemplo:**
```
Beta(91, 11):
œÉ¬≤ = 91√ó11 / [102¬≤ √ó 103]
   ‚âà 0.000935
œÉ ‚âà 0.0306 = 3.06%
```

### Desvio Padr√£o

```
œÉ = ‚àö[Œ±Œ≤ / [(Œ±+Œ≤)¬≤(Œ±+Œ≤+1)]]
```

---

## üßÆ Por que Beta √© Perfeita para [[Acur√°cia]]?

### 1. Suporte Natural [0,1]

**Problema com Normal:**
```
Normal(0.98, 0.02¬≤) pode gerar valores > 1 ‚ùå
```

**Beta sempre respeita limites:**
```
Beta(Œ±, Œ≤) s√≥ gera valores em [0, 1] ‚úÖ
```

### 2. Flexibilidade

Pode representar:
- Ignor√¢ncia total: Beta(1,1)
- Alta confian√ßa: Beta(100, 10)
- Baixo desempenho: Beta(10, 100)
- Qualquer forma intermedi√°ria!

### 3. Conjuga√ß√£o com Binomial

**Classifica√ß√£o bin√°ria** = sequ√™ncia de Bernoulli = Binomial!

```
Prior: Œ∏ ~ Beta(Œ±‚ÇÄ, Œ≤‚ÇÄ)
Likelihood: k sucessos em n ‚Üí Binomial(n, Œ∏)
Posterior: Œ∏ ~ Beta(Œ±‚ÇÄ+k, Œ≤‚ÇÄ+n-k)  ‚úÖ Tamb√©m √© Beta!
```

**Matem√°tica elegante!** Veja [[Infer√™ncia_Bayesiana#Conjugate Priors]].

### 4. Interpreta√ß√£o Intuitiva

```
Œ± = "evid√™ncia de sucesso"
Œ≤ = "evid√™ncia de falha"
Œº = Œ±/(Œ±+Œ≤) = "taxa de sucesso"
```

Faz sentido intuitivo! üí°

---

## üî¨ Beta no [[The_Balanced_Accuracy_and_Its_Posterior_Distribution|Artigo Brodersen]]

### Para [[Acur√°cia]] Simples

**Dados:** C corretos, I incorretos

**Prior n√£o-informativo:** Beta(1, 1)

**Posterior:**
```
A ~ Beta(C+1, I+1)
```

**Exemplo:**
```
90 corretos, 10 incorretos
‚Üí Beta(91, 11)

M√©dia: 89.2%
IC 95%: [83.8%, 94.6%]
```

### Para [[Acur√°cia_Balanceada]]

**Dados:** TP, FN, TN, FP

**Acur√°cia em cada classe:**
```
A_pos ~ Beta(TP+1, FN+1)
A_neg ~ Beta(TN+1, FP+1)
```

**Balanced Accuracy:**
```
BA = ¬Ω(A_pos + A_neg)
```

**Distribui√ß√£o de BA:** Convolu√ß√£o! (se√ß√£o abaixo)

---

## üåÄ Convolu√ß√£o para Balanced Accuracy

### O Problema

Queremos a distribui√ß√£o de:
```
BA = ¬Ω(A_pos + A_neg)
```

Onde A_pos e A_neg s√£o **independentes** e seguem Betas.

### Solu√ß√£o: Convolu√ß√£o

**Do artigo, Equa√ß√£o (7):**

```
p_BA(x; TP, FP, FN, TN) = 
    ‚à´‚ÇÄ¬π p_A(2(x-z); TP+1, FN+1) √ó p_A(2z; TN+1, FP+1) dz
```

Onde:
- `p_A(x)` √© a PDF da Beta (definida acima)
- `p_BA(x)` √© a PDF da balanced accuracy

### Propriedades

- ‚ùå N√£o tem forma anal√≠tica fechada
- ‚úÖ Pode ser calculada numericamente
- ‚úÖ Respeita [0,1] naturalmente
- ‚úÖ Captura correla√ß√£o entre classes

### Implementa√ß√£o (Aproxima√ß√£o Monte Carlo)

```python
from scipy import stats
import numpy as np

def balanced_accuracy_distribution(TP, FN, TN, FP, n_samples=100000):
    """
    Aproxima distribui√ß√£o da balanced accuracy
    via amostragem Monte Carlo.
    """
    # Posteriors para cada classe
    pos_post = stats.beta(TP + 1, FN + 1)
    neg_post = stats.beta(TN + 1, FP + 1)
    
    # Amostrar
    pos_samples = pos_post.rvs(n_samples)
    neg_samples = neg_post.rvs(n_samples)
    
    # Balanced accuracy
    ba_samples = 0.5 * (pos_samples + neg_samples)
    
    return ba_samples

# Exemplo do artigo (C2)
# 45 positivos: 43 TP, 2 FN
# 10 negativos: 3 TN, 7 FP
TP, FN, TN, FP = 43, 2, 3, 7

ba_samples = balanced_accuracy_distribution(TP, FN, TN, FP)

print(f"BA m√©dia: {np.mean(ba_samples):.3f}")
print(f"IC 95%: [{np.percentile(ba_samples, 2.5):.3f}, "
      f"{np.percentile(ba_samples, 97.5):.3f}]")

# Resultado aproximado:
# BA m√©dia: 0.512
# IC 95%: [0.384, 0.639]
```

---

## üé≤ Simula√ß√£o e Visualiza√ß√£o

### Comparando Diferentes Evid√™ncias

```python
import matplotlib.pyplot as plt
import numpy as np
from scipy import stats

x = np.linspace(0, 1, 1000)

# Diferentes n√≠veis de evid√™ncia
fig, axes = plt.subplots(2, 2, figsize=(12, 10))

configs = [
    (2, 2, "Pouca evid√™ncia balanceada"),
    (10, 10, "Evid√™ncia moderada balanceada"),
    (91, 11, "Muita evid√™ncia (90/100 acertos)"),
    (10, 91, "Muita evid√™ncia (10/100 acertos)")
]

for ax, (alpha, beta, title) in zip(axes.flat, configs):
    dist = stats.beta(alpha, beta)
    
    ax.plot(x, dist.pdf(x), 'b-', lw=2)
    ax.fill_between(x, dist.pdf(x), alpha=0.3)
    
    # Estat√≠sticas
    mean = dist.mean()
    ci = dist.interval(0.95)
    
    ax.axvline(mean, color='r', linestyle='--', 
               label=f'M√©dia: {mean:.3f}')
    ax.axvline(ci[0], color='g', linestyle=':', alpha=0.5)
    ax.axvline(ci[1], color='g', linestyle=':', alpha=0.5,
               label=f'IC 95%: [{ci[0]:.3f}, {ci[1]:.3f}]')
    
    ax.set_title(f'{title}\nBeta({alpha}, {beta})')
    ax.set_xlabel('x (acur√°cia)')
    ax.set_ylabel('Densidade')
    ax.legend()
    ax.grid(alpha=0.3)

plt.tight_layout()
plt.savefig('beta_comparison.png', dpi=300)
plt.show()
```

### Atualiza√ß√£o Bayesiana Sequencial

```python
# Come√ßar com prior n√£o-informativo
prior = stats.beta(1, 1)

# Observar dados sequencialmente
observations = [(1,0), (1,0), (0,1), (1,0), (1,0)]  # (sucesso, falha)

alpha, beta = 1, 1

for i, (succ, fail) in enumerate(observations):
    # Atualizar
    alpha += succ
    beta += fail
    
    # Posterior atual
    posterior = stats.beta(alpha, beta)
    
    # Visualizar evolu√ß√£o
    x = np.linspace(0, 1, 1000)
    plt.plot(x, posterior.pdf(x), 
             label=f'Ap√≥s {i+1} obs: Beta({alpha},{beta})')

plt.title('Evolu√ß√£o da Cren√ßa Bayesiana')
plt.xlabel('Œ∏ (taxa de sucesso)')
plt.ylabel('Densidade')
plt.legend()
plt.grid(alpha=0.3)
plt.show()
```

---

## üìö Propriedades Matem√°ticas Avan√ßadas

### Fun√ß√£o Geradora de Momentos

N√£o tem forma fechada simples, mas momentos podem ser calculados:

```
E[X^n] = (Œ±)_n / (Œ±+Œ≤)_n
```

Onde `(a)_n` √© o s√≠mbolo de Pochhammer (rising factorial).

### Entropia

```
H(X) = ln B(Œ±,Œ≤) - (Œ±-1)œà(Œ±) - (Œ≤-1)œà(Œ≤) + (Œ±+Œ≤-2)œà(Œ±+Œ≤)
```

Onde œà √© a fun√ß√£o digamma.

### Informa√ß√£o de Fisher

```
I(Œ±,Œ≤) = matriz 2√ó2 das segundas derivadas de ln L
```

---

## üîÑ Rela√ß√µes com Outras Distribui√ß√µes

### Beta e Uniforme

```
Beta(1, 1) = Uniforme(0, 1)
```

### Beta e Binomial

**Conjuga√ß√£o:**
```
Prior: Beta(Œ±, Œ≤)
+ Likelihood: Binomial
= Posterior: Beta(Œ±+k, Œ≤+n-k)
```

### Beta e Dirichlet

**Generaliza√ß√£o multiclasse:**
```
Beta(Œ±, Œ≤) √© caso especial de Dirichlet(Œ±, Œ≤)
```

Para [[Acur√°cia_Balanceada]] multiclasse!

### Beta e F de Fisher

```
Se X ~ Beta(Œ±, Œ≤), ent√£o
Y = (X/Œ±) / ((1-X)/Œ≤) ~ F(2Œ±, 2Œ≤)
```

---

## üíª Implementa√ß√£o Completa

### Classe Beta Helper

```python
from scipy import stats
import numpy as np

class BetaAccuracy:
    """Helper para trabalhar com acur√°cias modeladas como Beta."""
    
    def __init__(self, correct, incorrect):
        """
        Args:
            correct: n√∫mero de classifica√ß√µes corretas
            incorrect: n√∫mero de classifica√ß√µes incorretas
        """
        self.C = correct
        self.I = incorrect
        self.alpha = correct + 1
        self.beta = incorrect + 1
        self.dist = stats.beta(self.alpha, self.beta)
    
    def mean(self):
        """Acur√°cia m√©dia."""
        return self.dist.mean()
    
    def median(self):
        """Mediana."""
        return self.dist.median()
    
    def mode(self):
        """Moda (MLE)."""
        if self.alpha > 1 and self.beta > 1:
            return (self.alpha - 1) / (self.alpha + self.beta - 2)
        return np.nan
    
    def std(self):
        """Desvio padr√£o."""
        return self.dist.std()
    
    def interval(self, confidence=0.95):
        """Intervalo de credibilidade."""
        return self.dist.interval(confidence)
    
    def prob_greater_than(self, threshold):
        """P(acur√°cia > threshold)."""
        return 1 - self.dist.cdf(threshold)
    
    def prob_between(self, lower, upper):
        """P(lower < acur√°cia < upper)."""
        return self.dist.cdf(upper) - self.dist.cdf(lower)
    
    def compare_with(self, other_beta_acc, n_samples=100000):
        """
        Compara com outro modelo.
        Retorna P(este modelo > outro modelo).
        """
        samples_self = self.dist.rvs(n_samples)
        samples_other = other_beta_acc.dist.rvs(n_samples)
        return np.mean(samples_self > samples_other)
    
    def summary(self):
        """Resumo completo."""
        ci = self.interval(0.95)
        return f"""
        Beta({self.alpha}, {self.beta})
        ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        M√©dia:    {self.mean():.4f}
        Mediana:  {self.median():.4f}
        Moda:     {self.mode():.4f}
        Desvio:   {self.std():.4f}
        IC 95%:   [{ci[0]:.4f}, {ci[1]:.4f}]
        """

# Uso
model_A = BetaAccuracy(correct=90, incorrect=10)
print(model_A.summary())

# P(acur√°cia > 85%)
print(f"P(acc > 0.85): {model_A.prob_greater_than(0.85):.3f}")

# Comparar modelos
model_B = BetaAccuracy(correct=85, incorrect=15)
prob = model_A.compare_with(model_B)
print(f"P(A > B): {prob:.3f}")
```

---

## üìö Refer√™ncias

### Livros Espec√≠ficos
- **Gelman, A., et al.** (2013). *Bayesian Data Analysis* (3rd ed.). CRC Press. [Se√ß√£o 2.4: "Bayesian inference for Binomial data"]
- **Kruschke, J.K.** (2014). *Doing Bayesian Data Analysis* (2nd ed.). Academic Press. [Cap√≠tulo 6: "Inferring a Binomial Probability"]
- **Bishop, C.M.** (2006). *Pattern Recognition and Machine Learning*. Springer. [Se√ß√£o 2.2, pp. 68-74] ‚≠ê **Citado no artigo!**

### Papers
- **Brodersen et al.** (2010). [[The_Balanced_Accuracy_and_Its_Posterior_Distribution|"The balanced accuracy and its posterior distribution"]]. ICPR.

### Online
- [Beta Distribution - Wikipedia](https://en.wikipedia.org/wiki/Beta_distribution)
- [Seeing Theory: Beta Distribution](https://seeing-theory.brown.edu/bayesian-inference/index.html)
- [Scipy Documentation](https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.beta.html)

Veja [[Refer√™ncias_Bibliogr√°ficas]] para lista completa.

---

## üîó Conceitos Relacionados

### Fundamentos
- [[Distribui√ß√µes_de_Probabilidade]] - Contexto geral
- [[M√©dia_Desvio_Padr√£o_Erro_Padr√£o]] - Momentos
- [[Intervalos_de_Confian√ßa]] - Aplica√ß√£o principal

### Paradigma
- [[Infer√™ncia_Bayesiana]] - Framework de uso
- [[M√©todos_Param√©tricos_vs_N√£o_Param√©tricos]] - Escolha param√©trica

### Aplica√ß√µes
- [[Acur√°cia]] - Modelada como Beta
- [[Acur√°cia_Balanceada]] - Convolu√ß√£o de Betas
- [[The_Balanced_Accuracy_and_Its_Posterior_Distribution]] - Artigo principal
- [[Aplica√ß√£o_ao_IoT_IDS]] - Uso pr√°tico

---

## üéØ Exerc√≠cios

Veja [[Exerc√≠cios_Pr√°ticos#Distribui√ß√£o Beta]].

---

## üìå Resumo Visual

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ            DISTRIBUI√á√ÉO BETA                  ‚îÇ
‚îÇ                                               ‚îÇ
‚îÇ  Beta(Œ±, Œ≤) para x ‚àà [0,1]                   ‚îÇ
‚îÇ                                               ‚îÇ
‚îÇ  Œ± = "sucessos" + 1                          ‚îÇ
‚îÇ  Œ≤ = "falhas" + 1                            ‚îÇ
‚îÇ                                               ‚îÇ
‚îÇ  ‚úÖ Suporte [0,1] - perfeito para propor√ß√µes ‚îÇ
‚îÇ  ‚úÖ Flex√≠vel - m√∫ltiplas formas              ‚îÇ
‚îÇ  ‚úÖ Conjugada √† Binomial                     ‚îÇ
‚îÇ  ‚úÖ Interpreta√ß√£o intuitiva                  ‚îÇ
‚îÇ                                               ‚îÇ
‚îÇ  Momentos:                                    ‚îÇ
‚îÇ  ‚Ä¢ M√©dia: Œ±/(Œ±+Œ≤)                            ‚îÇ
‚îÇ  ‚Ä¢ Vari√¢ncia: Œ±Œ≤/[(Œ±+Œ≤)¬≤(Œ±+Œ≤+1)]            ‚îÇ
‚îÇ                                               ‚îÇ
‚îÇ  Uso: Modelar ACUR√ÅCIAS!                     ‚îÇ
‚îÇ                                               ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

**Tags:** #beta-distribution #bayesian #probability #accuracy #proportion #conjugate-prior

**Voltar para:** [[INDEX]]  
**Contexto:** [[Distribui√ß√µes_de_Probabilidade]]  
**Artigo:** [[The_Balanced_Accuracy_and_Its_Posterior_Distribution]]  
**Aplica√ß√£o:** [[Acur√°cia_Balanceada]]

